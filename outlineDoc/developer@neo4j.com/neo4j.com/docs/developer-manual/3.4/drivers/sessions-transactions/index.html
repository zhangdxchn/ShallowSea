
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml">
   <head>
      <meta charset="utf-8"></meta>
      <meta name="viewport" content="width=device-width, initial-scale=1.0"></meta>
      <title>4.3.&nbsp;Sessions and transactions - Chapter&nbsp;4.&nbsp;Drivers</title>
      <link rel="stylesheet" type="text/css" href="../../docbook.css"></link>
      <link rel="stylesheet" type="text/css" href="../../../../../../maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css"></link>
      <link rel="stylesheet" type="text/css" href="../../../../../../cdnjs.cloudflare.com/ajax/libs/font-awesome/4.1.0/css/font-awesome.min.css"></link>
      <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Open+Sans:400,300,400italic,600,300italic"></link>
      <link rel="stylesheet" type="text/css" href="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/codemirror.min.css"></link>
      <link rel="stylesheet" type="text/css" href="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/theme/neo.min.css"></link>
      <link rel="stylesheet" type="text/css" href="../../css/extra.css"></link>
      <link rel="stylesheet" type="text/css" href="../../css/chunked-base.css"></link>
      <link rel="stylesheet" type="text/css" href="../../css/console.css"></link><script src="https://ajax.googleapis.com/ajax/libs/jquery/2.2.0/jquery.min.js" type="text/javascript"></script><script src="../../../../../../maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/codemirror.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/addon/runmode/runmode.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/mode/javascript/javascript.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/mode/shell/shell.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/mode/python/python.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/mode/xml/xml.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/mode/clike/clike.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/mode/cypher/cypher.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/mode/properties/properties.min.js" type="text/javascript"></script><script src="../../../../../../cdnjs.cloudflare.com/ajax/libs/codemirror/5.36.0/mode/groovy/groovy.min.js" type="text/javascript"></script><script src="../../javascript/colorize.js" type="text/javascript"></script><script src="../../javascript/tabs-for-chunked.js" type="text/javascript"></script><script src="../../javascript/mp-nav.js" type="text/javascript"></script><script src="../../javascript/versionswitcher.js" type="text/javascript"></script><script src="../../javascript/version.js" type="text/javascript"></script><script src="https://s3-eu-west-1.amazonaws.com/alpha.neohq.net/docs/new-manual/assets/search.js" type="text/javascript"></script><meta name="generator" content="DocBook XSL Stylesheets V1.79.1"></meta>
      <meta name="description" content="This section describes how to create units of work and provide a logical context for that work."></meta>
      <link rel="prev" href="../client-applications/index.html" title="4.2.&nbsp;Client applications"></link>
      <link rel="next" href="../cypher-values/index.html" title="4.4.&nbsp;Working with Cypher values"></link>
      <link rel="shortcut icon" href="../../../../../wp-content/themes/neo4jweb/favicon.ico"></link><script>
        $(document).ready(function() {
          CodeMirror.colorize();
          tabTheSource($('body'));
          var $header = $('header').first();
          $header.prepend(
            $('<a href="../../index.html" id="logo"><img src="../../../../../wp-content/themes/neo4jweb/assets/images/neo4j-logo-2015.png" alt="Neo4j Logo"></img></a>')
          );
          var $sidebar = $('<div id="sidebar-wrapper"></div>');
          $.get('toc.html', function (d){
            $(d).appendTo($sidebar);
            highlightToc();
            highlightLibraryHeader();
          });
          $sidebar.insertAfter($('header').first());
        });
        </script></head>
   <body>
      <header>
         <div class="searchbox">
            <form id="search-form" class="search" name="search-form" role="search"><input id="search-form-input" name="q" title="search" type="search" lang="en" placeholder="Search Neo4j docs..." aria-label="Search Neo4j documentation" max-length="128" required="required"></input><input id="search-form-button" type="submit" value="Search"></input></form>
         </div>
         <ul class="documentation-library">
            <li><a href="https://neo4j.com/docs/operations-manual/3.4/">Operations Manual</a></li>
            <li><a href="../../index.html">Developer Manual</a></li>
            <li><a href="https://neo4j.com/docs/ogm-manual/3.0/">OGM Manual</a></li>
            <li><a href="https://neo4j.com/docs/graph-algorithms/3.4/">Graph Algorithms</a></li>
            <li><a href="https://neo4j.com/docs/java-reference/3.4/">Java Reference</a></li>
         </ul>
         <nav id="header-nav"><span class="nav-previous"><a accesskey="p" href="../client-applications/index.html"><span class="fa fa-long-arrow-left" aria-hidden="true"></span>Client applications</a></span><span class="nav-current">
               <p class="nav-title hidden">4.3.&nbsp;Sessions and transactions</p></span><span class="nav-next"><a accesskey="n" href="../cypher-values/index.html">Working with Cypher values<span class="fa fa-long-arrow-right" aria-hidden="true"></span></a></span></nav>
      </header>
      <div id="search-results" class="hidden"></div>
      <section class="section" id="driver-sessions-transactions">
         <div class="titlepage">
            <div>
               <div>
                  <h2 class="title" style="clear: both"><a class="anchor" href="index.html#driver-sessions-transactions"></a>4.3.&nbsp;Sessions and transactions
                  </h2>
               </div>
            </div>
         </div>
         <div class="abstract">
            <p>This section describes how to create units of work and provide a logical context for that work.</p>
         </div>
         <section class="section" id="driver-sessions">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a class="anchor" href="index.html#driver-sessions"></a>4.3.1.&nbsp;Sessions
                     </h3>
                  </div>
               </div>
            </div>
            <p>A session is a container for a sequence of transactions.
               Sessions borrow connections from a pool as required and so should be considered lightweight and disposable.
               In languages where <a class="link" href="../../terminology/index.html#term-thread-safety">thread safety</a> is an issue, a session should <span class="emphasis"><em>not</em></span> be considered thread-safe.
            </p>
            <p>In languages that support them, sessions are usually scoped within a context block.
               This ensures that they are properly closed and that any underlying connections are released and not leaked.
            </p>
            <div class="example tabbed-example" id="d0e65139">
               <div class="example-title">Example&nbsp;4.18.&nbsp;Session</div>
               <div class="example tabbed-example-contents">
                  <div class="informalexample include-with-dotnet"><pre class="programlisting highlight"><code data-lang="csharp">public void AddPerson(string name)
{
    using (var session = Driver.Session())
    {
        session.Run("CREATE (a:Person {name: $name})", new {name});
    }
}</code></pre></div>
                  <div class="informalexample include-with-java"><pre class="programlisting highlight"><code data-lang="java">public void addPerson(String name)
{
    try ( Session session = driver.session() )
    {
        session.run("CREATE (a:Person {name: $name})", parameters( "name", name ) );
    }
}</code></pre></div>
                  <div class="informalexample include-with-javascript"><pre class="programlisting highlight"><code data-lang="javascript">const session = driver.session();

session.run('CREATE (a:Person {name: $name})', {'name': personName}).then(() =&gt; {
  session.close(() =&gt; {
    console.log('Person created, session closed');
  });
});</code></pre></div>
                  <div class="informalexample include-with-python"><pre class="programlisting highlight"><code data-lang="python">def add_person(self, name):
    with self._driver.session() as session:
        session.run("CREATE (a:Person {name: $name})", name=name)</code></pre></div>
               </div>
            </div>
         </section>
         <section class="section" id="driver-transactions">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a class="anchor" href="index.html#driver-transactions"></a>4.3.2.&nbsp;Transactions
                     </h3>
                  </div>
               </div>
            </div>
            <p>Transactions are atomic units of work consisting of one or more Cypher statement executions.
               A transaction is executed within a session.
            </p>
            <p>To execute a Cypher statement, two pieces of information are required: the statement template and a keyed set of parameters.
               The template is a string containing placeholders that are substituted with parameter values at runtime.
               While it is possible to run non-parameterized Cypher, good programming practice is to use parameters in Cypher statements.
               This allows for caching of statements within the Cypher engine, which is beneficial for performance.
               Parameter values should adhere to <a class="xref" href="../../cypher/syntax/values/index.html" title="3.2.1.&nbsp;Values and types">Section&nbsp;3.2.1, &#8220;Values and types&#8221;</a>.
            </p>
            <p>The Neo4j driver API provides for three forms of transaction:</p>
            <div class="itemizedlist">
               <ul class="itemizedlist" style="list-style-type: disc; ">
                  <li class="listitem">Auto-commit transactions</li>
                  <li class="listitem">Transaction functions</li>
                  <li class="listitem">Explicit transactions</li>
               </ul>
            </div>
            <p>Of these, only <a class="link" href="index.html#driver-transactions-transaction-functions" title="4.3.2.2.&nbsp;Transaction functions">transaction function</a> can be automatically replayed on failure.
            </p>
            <section class="section" id="driver-transactions-auto-commit">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="index.html#driver-transactions-auto-commit"></a>4.3.2.1.&nbsp;Auto-commit Transactions
                        </h4>
                     </div>
                  </div>
               </div>
               <p>An auto-commit transaction is a simple but limited form of transaction.
                  Such a transaction consists of only one Cypher statement, cannot be automatically replayed on failure, and cannot take part
                  in a <a class="link" href="index.html#driver-transactions-causal-chaining" title="4.3.3.&nbsp;Causal chaining">causal chain</a>.
               </p>
               <p>An auto-commit transaction is invoked using the <code class="literal">session.run</code> method:
               </p>
               <div class="example tabbed-example" id="d0e65193">
                  <div class="example-title">Example&nbsp;4.19.&nbsp;Auto-commit transaction</div>
                  <div class="example tabbed-example-contents">
                     <div class="informalexample include-with-dotnet"><pre class="programlisting highlight"><code data-lang="csharp">public void AddPerson(string name)
{
    using (var session = Driver.Session())
    {
        session.Run("CREATE (a:Person {name: $name})", new {name});
    }
}</code></pre></div>
                     <div class="informalexample include-with-java"><pre class="programlisting highlight"><code data-lang="java">public void addPerson( String name )
{
    try ( Session session = driver.session() )
    {
        session.run( "CREATE (a:Person {name: $name})", parameters( "name", name ) );
    }
}</code></pre></div>
                     <div class="informalexample include-with-javascript"><pre class="programlisting highlight"><code data-lang="javascript">function addPerson(name) {
  const session = driver.session();
  return session.run('CREATE (a:Person {name: $name})', {name: name}).then(result =&gt; {
    session.close();
    return result;
  });
}</code></pre></div>
                     <div class="informalexample include-with-python"><pre class="programlisting highlight"><code data-lang="python">def add_person(self, name):
    with self._driver.session() as session:
        session.run("CREATE (a:Person {name: $name})", name=name)</code></pre></div>
                  </div>
               </div>
               <p>Auto-commit transactions are sent to the network and acknowledged immediately.
                  This means that multiple transactions cannot share network packets, thereby exhibiting a lesser network efficiency than other
                  forms of transaction.
               </p>
               <p>Auto-commit transactions are intended to be used for simple use cases such as when learning Cypher or writing one-off scripts.
                  It is not recommended to use auto-commit transactions in production environments or when performance or resilience are a primary
                  concern.
               </p>
               <p>However, Auto-commit transactions are the only way to execute <code class="literal"><a class="link" href="../../cypher/query-tuning/using/index.html#query-using-periodic-commit-hint" title="3.6.4.5.&nbsp;PERIODIC COMMIT query hint">USING PERIODIC COMMIT</a></code> Cypher statements.
               </p>
            </section>
            <section class="section" id="driver-transactions-transaction-functions">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="index.html#driver-transactions-transaction-functions"></a>4.3.2.2.&nbsp;Transaction functions
                        </h4>
                     </div>
                  </div>
               </div>
               <p>Transaction functions are the recommended form for containing transactional units of work.
                  This form requires minimal boilerplate code and allows for a clear separation of database queries and application logic.
               </p>
               <div class="example tabbed-example" id="d0e65223">
                  <div class="example-title">Example&nbsp;4.20.&nbsp;Transaction function</div>
                  <div class="example tabbed-example-contents">
                     <div class="informalexample include-with-dotnet"><pre class="programlisting highlight"><code data-lang="csharp">public void AddPerson(string name)
{
    using (var session = Driver.Session())
    {
        session.WriteTransaction(tx =&gt; tx.Run("CREATE (a:Person {name: $name})", new {name}));
    }
}</code></pre></div>
                     <div class="informalexample include-with-java"><pre class="programlisting highlight"><code data-lang="java">public void addPerson( final String name )
{
    try ( Session session = driver.session() )
    {
        session.writeTransaction( new TransactionWork&lt;Integer&gt;()
        {
            @Override
            public Integer execute( Transaction tx )
            {
                return createPersonNode( tx, name );
            }
        } );
    }
}

private static int createPersonNode( Transaction tx, String name )
{
    tx.run( "CREATE (a:Person {name: $name})", parameters( "name", name ) );
    return 1;
}</code></pre></div>
                     <div class="informalexample include-with-javascript"><pre class="programlisting highlight"><code data-lang="javascript">const session = driver.session();
const writeTxPromise = session.writeTransaction(tx =&gt; tx.run('CREATE (a:Person {name: $name})', {'name': personName}));

writeTxPromise.then(result =&gt; {
  session.close();

  if (result) {
    console.log('Person created');
  }
});</code></pre></div>
                     <div class="informalexample include-with-python"><pre class="programlisting highlight"><code data-lang="python">def add_person(self, name):
    with self._driver.session() as session:
        session.write_transaction(self.create_person_node, name)

@staticmethod
def create_person_node(tx, name):
    tx.run("CREATE (a:Person {name: $name})", name=name)</code></pre></div>
                  </div>
               </div>
               <p>Transaction functions are also able to handle connection problems and transient errors using an automatic retry mechanism.
                  This retry capability can be <a class="link" href="../client-applications/index.html#driver-configuration-max-retry-time" title="4.2.4.6.&nbsp;Max retry time">configured</a> on Driver construction.
               </p>
               <p>Any query results obtained within a transaction function should be consumed within that function.
                  Transaction functions can return values but these should be derived values rather than raw results.
               </p>
            </section>
            <section class="section" id="driver-transactions-explicit">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="index.html#driver-transactions-explicit"></a>4.3.2.3.&nbsp;Explicit transactions
                        </h4>
                     </div>
                  </div>
               </div>
               <p>Explicit transactions are the longhand form of transaction functions, providing access to explicit <code class="literal">BEGIN</code>, <code class="literal">COMMIT</code> and <code class="literal">ROLLBACK</code> operations.
                  While this form is useful for a handful of use cases, it is recommended to use transaction functions wherever possible.
               </p>
            </section>
            <section class="section" id="driver-transactions-cypher-errors">
               <div class="titlepage">
                  <div>
                     <div>
                        <h4 class="title"><a class="anchor" href="index.html#driver-transactions-cypher-errors"></a>4.3.2.4.&nbsp;Cypher errors
                        </h4>
                     </div>
                  </div>
               </div>
               <p>When executing Cypher, it is possible for an exception to be thrown by the Cypher engine.
                  Each such exception is associated with a <a class="link" href="../../reference/status-codes/index.html" title="A.1.&nbsp;Neo4j Status Codes">status code</a> that describes the nature of the error and a message that provides more detail.
               </p>
               <p>The error classifications are listed in the table below.</p>
               <div class="table" id="d0e65269">
                  <table class="table" summary="Error classifications" border="1">
                     <caption class="table-title">Table&nbsp;4.4.&nbsp;Error classifications</caption>
                     <colgroup>
                        <col class="col_1"></col>
                        <col class="col_2"></col>
                     </colgroup>
                     <thead>
                        <tr>
                           <th style="text-align: left; vertical-align: top; ">Classification</th>
                           <th style="text-align: left; vertical-align: top; ">Description</th>
                        </tr>
                     </thead>
                     <tbody>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>ClientError</p>
                           </td>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>The client application has caused an error.
                                 The application should amend and retry the operation.
                              </p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>DatabaseError</p>
                           </td>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>The server has caused an error.
                                 Retrying the operation will generally be unsuccessful.
                              </p>
                           </td>
                        </tr>
                        <tr>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>TransientError</p>
                           </td>
                           <td style="text-align: left; vertical-align: top; ">
                              <p>A temporary error has occurred.
                                 The application should retry the operation.
                              </p>
                           </td>
                        </tr>
                     </tbody>
                  </table>
               </div>
            </section>
         </section>
         <section class="section" id="driver-transactions-causal-chaining">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a class="anchor" href="index.html#driver-transactions-causal-chaining"></a>4.3.3.&nbsp;Causal chaining
                     </h3>
                  </div>
               </div>
            </div>
            <p>When working with a causal cluster, transactions can be chained to ensure causal consistency.
               This means that for any two transactions, it is guaranteed that the second transaction will begin only after the first has
               been successfully committed.
               This is true even if the transactions are carried out on different physical cluster members.
            </p>
            <div class="admonitionblock note">
               <table>
                  <tbody>
                     <tr>
                        <td class="icon"><i class="fa icon-note" title="note"></i></td>
                        <td class="content">
                           <p>Due to protocol limitations, <a class="link" href="index.html#driver-transactions-auto-commit" title="4.3.2.1.&nbsp;Auto-commit Transactions">auto-commit transactions</a> cannot currently take part in the causal chain.
                              While this is expected to change in a future protocol release, <code class="literal">session.run</code> calls should be avoided in places where causal consistency is important.
                           </p>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </div>
            <p>Causal chaining is carried out by passing <a class="link" href="../../terminology/index.html#term-bookmark">bookmarks</a> between transactions.
               Each bookmark records a point in transactional history and can be used to inform cluster members to carry out units of work
               in a particular sequence.
               Internally, a bookmark is passed from server to client on a successful COMMIT and back from client to server on BEGIN.
               On receipt of one or more bookmarks, the transaction server will block until it has fast forwarded to catch up with the latest
               of these.
            </p>
            <p>Within a session, bookmark propagation is carried out automatically and does not require any explicit signal or setting from
               the application.
               To opt out of this mechanism for unrelated units of work, applications can use multiple sessions.
               This avoids the small latency overhead of the causal chain.
               Propagation between sessions can be achieved by extracting the last bookmarks from one or more sessions and passing these
               into the construction of another.
               This is generally the only case in which an application will need to work with bookmarks directly.
            </p>
            <div class="figure" id="d0e65324">
               <div class="figure-title">Figure&nbsp;4.1.&nbsp;Passing bookmarks</div>
               <div class="figure-contents">
                  <div class="mediaobject"><img src="../../images/driver-passing-bookmarks.svg" alt="driver passing bookmarks"></img></div>
               </div>
            </div>
            <p>The following example illustrates the passing of bookmarks between sessions.
               First consider the code:
            </p>
            <div class="example tabbed-example" id="d0e65335">
               <div class="example-title">Example&nbsp;4.21.&nbsp;Passing bookmarks between sessions</div>
               <div class="example tabbed-example-contents">
                  <div class="informalexample include-with-dotnet"><pre class="programlisting highlight"><code data-lang="csharp">// Create a company node
private void AddCompany(ITransaction tx, string name)
{
    tx.Run("CREATE (a:Company {name: $name})", new {name});
}

// Create a person node
private void AddPerson(ITransaction tx, string name)
{
    tx.Run("CREATE (a:Person {name: $name})", new {name});
}

// Create an employment relationship to a pre-existing company node.
// This relies on the person first having been created.
private void Employ(ITransaction tx, string personName, string companyName)
{
    tx.Run(@"MATCH (person:Person {name: $personName})
             MATCH (company:Company {name: $companyName})
             CREATE (person)-[:WORKS_FOR]-&gt;(company)", new {personName, companyName});
}

// Create a friendship between two people.
private void MakeFriends(ITransaction tx, string name1, string name2)
{
    tx.Run(@"MATCH (a:Person {name: $name1})
             MATCH (b:Person {name: $name2})
             MERGE (a)-[:KNOWS]-&gt;(b)", new {name1, name2});
}

// Match and display all friendships.
private void PrintFriendships(ITransaction tx)
{
    var result = tx.Run("MATCH (a)-[:KNOWS]-&gt;(b) RETURN a.name, b.name");

    foreach (var record in result)
    {
        Console.WriteLine($"{record["a.name"]} knows {record["b.name"]}");
    }
}

public void AddEmployAndMakeFriends()
{
    // To collect the session bookmarks
    var savedBookmarks = new List&lt;string&gt;();

    // Create the first person and employment relationship.
    using (var session1 = Driver.Session(AccessMode.Write))
    {
        session1.WriteTransaction(tx =&gt; AddCompany(tx, "Wayne Enterprises"));
        session1.WriteTransaction(tx =&gt; AddPerson(tx, "Alice"));
        session1.WriteTransaction(tx =&gt; Employ(tx, "Alice", "Wayne Enterprises"));

        savedBookmarks.Add(session1.LastBookmark);
    }

    // Create the second person and employment relationship.
    using (var session2 = Driver.Session(AccessMode.Write))
    {
        session2.WriteTransaction(tx =&gt; AddCompany(tx, "LexCorp"));
        session2.WriteTransaction(tx =&gt; AddPerson(tx, "Bob"));
        session2.WriteTransaction(tx =&gt; Employ(tx, "Bob", "LexCorp"));

        savedBookmarks.Add(session2.LastBookmark);
    }

    // Create a friendship between the two people created above.
    using (var session3 = Driver.Session(AccessMode.Write, savedBookmarks))
    {
        session3.WriteTransaction(tx =&gt; MakeFriends(tx, "Alice", "Bob"));

        session3.ReadTransaction(PrintFriendships);
    }
}</code></pre></div>
                  <div class="informalexample include-with-java"><pre class="programlisting highlight"><code data-lang="java">// Create a company node
private StatementResult addCompany( final Transaction tx, final String name )
{
    return tx.run( "CREATE (:Company {name: $name})", parameters( "name", name ) );
}

// Create a person node
private StatementResult addPerson( final Transaction tx, final String name )
{
    return tx.run( "CREATE (:Person {name: $name})", parameters( "name", name ) );
}

// Create an employment relationship to a pre-existing company node.
// This relies on the person first having been created.
private StatementResult employ( final Transaction tx, final String person, final String company )
{
    return tx.run( "MATCH (person:Person {name: $person_name}) " +
                    "MATCH (company:Company {name: $company_name}) " +
                    "CREATE (person)-[:WORKS_FOR]-&gt;(company)",
            parameters( "person_name", person, "company_name", company ) );
}

// Create a friendship between two people.
private StatementResult makeFriends( final Transaction tx, final String person1, final String person2 )
{
    return tx.run( "MATCH (a:Person {name: $person_1}) " +
                    "MATCH (b:Person {name: $person_2}) " +
                    "MERGE (a)-[:KNOWS]-&gt;(b)",
            parameters( "person_1", person1, "person_2", person2 ) );
}

// Match and display all friendships.
private StatementResult printFriends( final Transaction tx )
{
    StatementResult result = tx.run( "MATCH (a)-[:KNOWS]-&gt;(b) RETURN a.name, b.name" );
    while ( result.hasNext() )
    {
        Record record = result.next();
        System.out.println( String.format( "%s knows %s", record.get( "a.name" ).asString(), record.get( "b.name" ).toString() ) );
    }
    return result;
}

public void addEmployAndMakeFriends()
{
    // To collect the session bookmarks
    List&lt;String&gt; savedBookmarks = new ArrayList&lt;&gt;();

    // Create the first person and employment relationship.
    try ( Session session1 = driver.session( AccessMode.WRITE ) )
    {
        session1.writeTransaction( tx -&gt; addCompany( tx, "Wayne Enterprises" ) );
        session1.writeTransaction( tx -&gt; addPerson( tx, "Alice" ) );
        session1.writeTransaction( tx -&gt; employ( tx, "Alice", "Wayne Enterprises" ) );

        savedBookmarks.add( session1.lastBookmark() );
    }

    // Create the second person and employment relationship.
    try ( Session session2 = driver.session( AccessMode.WRITE ) )
    {
        session2.writeTransaction( tx -&gt; addCompany( tx, "LexCorp" ) );
        session2.writeTransaction( tx -&gt; addPerson( tx, "Bob" ) );
        session2.writeTransaction( tx -&gt; employ( tx, "Bob", "LexCorp" ) );

        savedBookmarks.add( session2.lastBookmark() );
    }

    // Create a friendship between the two people created above.
    try ( Session session3 = driver.session( AccessMode.WRITE, savedBookmarks ) )
    {
        session3.writeTransaction( tx -&gt; makeFriends( tx, "Alice", "Bob" ) );

        session3.readTransaction( this::printFriends );
    }
}</code></pre></div>
                  <div class="informalexample include-with-javascript"><pre class="programlisting highlight"><code data-lang="javascript">// Create a company node
function addCompany(tx, name) {
  return tx.run('CREATE (a:Company {name: $name})', {'name': name});
}

// Create a person node
function addPerson(tx, name) {
  return tx.run('CREATE (a:Person {name: $name})', {'name': name});
}

// Create an employment relationship to a pre-existing company node.
// This relies on the person first having been created.
function addEmployee(tx, personName, companyName) {
  return tx.run('MATCH (person:Person {name: $personName}) ' +
    'MATCH (company:Company {name: $companyName}) ' +
    'CREATE (person)-[:WORKS_FOR]-&gt;(company)', {'personName': personName, 'companyName': companyName});
}

// Create a friendship between two people.
function makeFriends(tx, name1, name2) {
  return tx.run('MATCH (a:Person {name: $name1}) ' +
    'MATCH (b:Person {name: $name2}) ' +
    'MERGE (a)-[:KNOWS]-&gt;(b)', {'name1': name1, 'name2': name2});
}

// To collect friend relationships
const friends = [];

// Match and display all friendships.
function findFriendships(tx) {
  const result = tx.run('MATCH (a)-[:KNOWS]-&gt;(b) RETURN a.name, b.name');

  result.subscribe({
    onNext: record =&gt; {
      const name1 = record.get(0);
      const name2 = record.get(1);

      friends.push({'name1': name1, 'name2': name2});
    }
  });
}

// To collect the session bookmarks
const savedBookmarks = [];

// Create the first person and employment relationship.
const session1 = driver.session(neo4j.WRITE);
const first = session1.writeTransaction(tx =&gt; addCompany(tx, 'Wayne Enterprises')).then(
  () =&gt; session1.writeTransaction(tx =&gt; addPerson(tx, 'Alice'))).then(
  () =&gt; session1.writeTransaction(tx =&gt; addEmployee(tx, 'Alice', 'Wayne Enterprises'))).then(
  () =&gt; {
    savedBookmarks.push(session1.lastBookmark());

    return session1.close();
  });

// Create the second person and employment relationship.
const session2 = driver.session(neo4j.WRITE);
const second = session2.writeTransaction(tx =&gt; addCompany(tx, 'LexCorp')).then(
  () =&gt; session2.writeTransaction(tx =&gt; addPerson(tx, 'Bob'))).then(
  () =&gt; session2.writeTransaction(tx =&gt; addEmployee(tx, 'Bob', 'LexCorp'))).then(
  () =&gt; {
    savedBookmarks.push(session2.lastBookmark());

    return session2.close();
  });

// Create a friendship between the two people created above.
const last = Promise.all([first, second]).then(ignore =&gt; {
  const session3 = driver.session(neo4j.WRITE, savedBookmarks);

  return session3.writeTransaction(tx =&gt; makeFriends(tx, 'Alice', 'Bob')).then(
    () =&gt; session3.readTransaction(findFriendships).then(
      () =&gt; session3.close()
    )
  );
});</code></pre></div>
                  <div class="informalexample include-with-python"><pre class="programlisting highlight"><code data-lang="python">class BookmarksExample(object):

    def __init__(self, uri, user, password):
        self._driver = GraphDatabase.driver(uri, auth=(user, password))

    def close(self):
        self._driver.close()

    # Create a person node.
    @classmethod
    def create_person(cls, tx, name):
        tx.run("CREATE (:Person {name: $name})", name=name)

    # Create an employment relationship to a pre-existing company node.
    # This relies on the person first having been created.
    @classmethod
    def employ(cls, tx, person_name, company_name):
        tx.run("MATCH (person:Person {name: $person_name}) "
               "MATCH (company:Company {name: $company_name}) "
               "CREATE (person)-[:WORKS_FOR]-&gt;(company)",
               person_name=person_name, company_name=company_name)

    # Create a friendship between two people.
    @classmethod
    def create_friendship(cls, tx, name_a, name_b):
        tx.run("MATCH (a:Person {name: $name_a}) "
               "MATCH (b:Person {name: $name_b}) "
               "MERGE (a)-[:KNOWS]-&gt;(b)",
               name_a=name_a, name_b=name_b)

    # Match and display all friendships.
    @classmethod
    def print_friendships(cls, tx):
        result = tx.run("MATCH (a)-[:KNOWS]-&gt;(b) RETURN a.name, b.name")
        for record in result:
            print("{} knows {}".format(record["a.name"] ,record["b.name"]))

    def main(self):
        saved_bookmarks = []  # To collect the session bookmarks

        # Create the first person and employment relationship.
        with self._driver.session() as session_a:
            session_a.write_transaction(self.create_person, "Alice")
            session_a.write_transaction(self.employ, "Alice", "Wayne Enterprises")
            saved_bookmarks.append(session_a.last_bookmark())

        # Create the second person and employment relationship.
        with self._driver.session() as session_b:
            session_b.write_transaction(self.create_person, "Bob")
            session_b.write_transaction(self.employ, "Bob", "LexCorp")
            saved_bookmarks.append(session_b.last_bookmark())

        # Create a friendship between the two people created above.
        with self._driver.session(bookmarks=saved_bookmarks) as session_c:
            session_c.write_transaction(self.create_friendship, "Alice", "Bob")
            session_c.read_transaction(self.print_friendships)</code></pre></div>
               </div>
            </div>
            <p>We are using three separate sessions: a, b and c.
               In <span class="emphasis"><em>session a</em></span> we run two separate transactions.
               In the first one we create the person <code class="literal">Alice</code>, and in the second one we record that she works at <code class="literal">Wayne Enterprises</code>.
               The bookmark being passed between the two transactions is handled by the session.
               The bookmark from the last transaction is saved into an array for future use.
            </p>
            <p>In <span class="emphasis"><em>session b</em></span> we also run two separate transactions.
               In the first one we create the person <code class="literal">Bob</code>, and in the second one we record that he works at <code class="literal">LexCorp</code>.
               Again, the bookmark being passed between the two transactions is handled by the session.
               The bookmark from the last transaction is saved into an array for future use.
            </p>
            <p>In the last session, <span class="emphasis"><em>session c</em></span>, we wish to create a friendship between Alice and Bob.
               This can only be done if both <code class="literal">Alice</code> and <code class="literal">Bob</code> have been created first.
               In order to ensure this, we pass the bookmarks from the last transactions in <span class="emphasis"><em>session a</em></span> and <span class="emphasis"><em>session b</em></span>, respectively.
            </p>
            <div class="admonitionblock tip">
               <table>
                  <tbody>
                     <tr>
                        <td class="icon"><i class="fa icon-tip" title="tip"></i></td>
                        <td class="content">
                           <p>If you try to extract a bookmark from a database which is not running in Causal Cluster mode, you will receive a <code class="literal">null</code> result.
                           </p>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </div>
         </section>
         <section class="section" id="driver-transactions-access-mode">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a class="anchor" href="index.html#driver-transactions-access-mode"></a>4.3.4.&nbsp;Access modes
                     </h3>
                  </div>
               </div>
            </div>
            <p>Transactions can be executed in either <code class="literal">read</code> or <code class="literal">write</code> mode.
               In a causal cluster, each transaction will be routed to an appropriate server based on the mode.
               When using a single instance, all transactions will be passed to that one server.
               Routing Cypher by identifying reads and writes can improve the utilization of available cluster resources:
               as read servers are typically more plentiful than write servers, it is beneficial to direct as much as possible of read transactions
               to read servers.
               Doing so helps keeping write servers available for write transactions.
            </p>
            <p>Access modes can be supplied in two ways: per transaction or per session.
               An access mode specified at session creation can be overridden by the access mode of a transaction within that session.
               In the general case, access mode should always be specified at transaction level, using <a class="link" href="index.html#driver-transactions-transaction-functions" title="4.3.2.2.&nbsp;Transaction functions">transaction functions</a>.
               The session-level setting is only necessary for explicit and auto-commit transactions.
            </p>
            <p>Note that the driver does not parse Cypher and cannot determine whether a transaction is intended to carry out read or write
               operations.
               As a result of this, a <code class="literal">write</code> transaction tagged for <code class="literal">read</code> will be sent to a read server, but will fail on execution.
            </p>
            <div class="example tabbed-example" id="d0e65419">
               <div class="example-title">Example&nbsp;4.22.&nbsp;Read-write transaction</div>
               <div class="example tabbed-example-contents">
                  <div class="informalexample include-with-dotnet"><pre class="programlisting highlight"><code data-lang="csharp">public long AddPerson(string name)
{
    using (var session = Driver.Session())
    {
        session.WriteTransaction(tx =&gt; CreatePersonNode(tx, name));
        return session.ReadTransaction(tx =&gt; MatchPersonNode(tx, name));
    }
}

private static void CreatePersonNode(ITransaction tx, string name)
{
    tx.Run("CREATE (a:Person {name: $name})", new {name});
}

private static long MatchPersonNode(ITransaction tx, string name)
{
    var result = tx.Run("MATCH (a:Person {name: $name}) RETURN id(a)", new {name});
    return result.Single()[0].As&lt;long&gt;();
}</code></pre></div>
                  <div class="informalexample include-with-java"><pre class="programlisting highlight"><code data-lang="java">public long addPerson( final String name )
{
    try ( Session session = driver.session() )
    {
        session.writeTransaction( new TransactionWork&lt;Void&gt;()
        {
            @Override
            public Void execute( Transaction tx )
            {
                return createPersonNode( tx, name );
            }
        } );
        return session.readTransaction( new TransactionWork&lt;Long&gt;()
        {
            @Override
            public Long execute( Transaction tx )
            {
                return matchPersonNode( tx, name );
            }
        } );
    }
}

private static Void createPersonNode( Transaction tx, String name )
{
    tx.run( "CREATE (a:Person {name: $name})", parameters( "name", name ) );
    return null;
}

private static long matchPersonNode( Transaction tx, String name )
{
    StatementResult result = tx.run( "MATCH (a:Person {name: $name}) RETURN id(a)", parameters( "name", name ) );
    return result.single().get( 0 ).asLong();
}</code></pre></div>
                  <div class="informalexample include-with-javascript"><pre class="programlisting highlight"><code data-lang="javascript">const session = driver.session();

const writeTxPromise = session.writeTransaction(tx =&gt; tx.run('CREATE (a:Person {name: $name})', {name: personName}));

writeTxPromise.then(() =&gt; {
  const readTxPromise = session.readTransaction(tx =&gt; tx.run('MATCH (a:Person {name: $name}) RETURN id(a)', {name: personName}));

  readTxPromise.then(result =&gt; {
    session.close();

    const singleRecord = result.records[0];
    const createdNodeId = singleRecord.get(0);

    console.log('Matched created node with id: ' + createdNodeId);
  });
});</code></pre></div>
                  <div class="informalexample include-with-python"><pre class="programlisting highlight"><code data-lang="python">def add_person(self, name):
    with self._driver.session() as session:
        session.write_transaction(self.create_person_node, name)
        return session.read_transaction(self.match_person_node, name)

@staticmethod
def create_person_node(tx, name):
    tx.run("CREATE (a:Person {name: $name})", name=name)
    return None

@staticmethod
def match_person_node(tx, name):
    result = tx.run("MATCH (a:Person {name: $name}) RETURN count(a)", name=name)
    return result.single()[0]</code></pre></div>
               </div>
            </div>
         </section>
         <section class="section" id="_asynchronous_programming">
            <div class="titlepage">
               <div>
                  <div>
                     <h3 class="title"><a class="anchor" href="index.html#_asynchronous_programming"></a>4.3.5.&nbsp;Asynchronous programming
                     </h3>
                  </div>
               </div>
            </div>
            <div class="admonitionblock note">
               <table>
                  <tbody>
                     <tr>
                        <td class="icon"><i class="fa icon-note" title="note"></i></td>
                        <td class="content">
                           <p>Java, .NET and JavaScript all support asynchronous programming.
                              The examples here highlight specifically how Java and .NET provide for this programming model alongside their blocking API.
                           </p>
                        </td>
                     </tr>
                  </tbody>
               </table>
            </div>
            <p>In addition to the methods listed in the previous sections, there also exist several asynchronous methods which allow for
               better integration with applications written in an asynchronous style.
               Asynchronous methods are named as their synchronous counterparts but with an additional <span class="emphasis"><em>async</em></span> prefix.
            </p>
            <div class="example tabbed-example" id="d0e65445">
               <div class="example-title">Example&nbsp;4.23.&nbsp;Asynchronous programming examples</div>
               <div class="example tabbed-example-contents">
                  <div class="informalexample include-with-dotnet">
                     <p><span class="formalpara-title">Auto-commit transactions.&nbsp;</span>
                        
                     </p><pre class="programlisting highlight"><code data-lang="csharp">var records = new List&lt;string&gt;();
var session = Driver.Session();

try
{
    // Send cypher statement to the database.
    // The existing IStatementResult interface implements IEnumerable
    // and does not play well with asynchronous use cases. The replacement
    // IStatementResultCursor interface is returned from the RunAsync
    // family of methods instead and provides async capable methods.
    var reader = await session.RunAsync(
        "MATCH (p:Product) WHERE p.id = $id RETURN p.title", // Cypher statement
        new { id = 0 } // Parameters in the statement, if any
    );

    // Loop through the records asynchronously
    while (await reader.FetchAsync())
    {
        // Each current read in buffer can be reached via Current
        records.Add(reader.Current[0].ToString());
    }
}
finally
{
    // asynchronously close session
    await session.CloseAsync();
}</code></pre><p>
                        
                     </p>
                     <p><span class="formalpara-title">Transaction functions.&nbsp;</span>
                        
                     </p><pre class="programlisting highlight"><code data-lang="csharp">var session = Driver.Session();

try
{
    // Wrap whole operation into an implicit transaction and
    // get the results back.
    result = await session.ReadTransactionAsync(async tx =&gt;
    {
        var records = new List&lt;string&gt;();

        // Send cypher statement to the database
        var reader = await tx.RunAsync(
            "MATCH (p:Product) WHERE p.id = $id RETURN p.title", // Cypher statement
            new { id = 0 } // Parameters in the statement, if any
        );

        // Loop through the records asynchronously
        while (await reader.FetchAsync())
        {
            // Each current read in buffer can be reached via Current
            records.Add(reader.Current[0].ToString());
        }

        return records;
    });
}
finally
{
    // asynchronously close session
    await session.CloseAsync();
}</code></pre><p>
                        
                     </p>
                     <p><span class="formalpara-title">Explicit transactions.&nbsp;</span>
                        
                     </p><pre class="programlisting highlight"><code data-lang="csharp">var records = new List&lt;string&gt;();
var session = Driver.Session();

try
{
    // Start an explicit transaction
    var tx = await session.BeginTransactionAsync();

    // Send cypher statement to the database through the explicit
    // transaction acquired
    var reader = await tx.RunAsync(
        "MATCH (p:Product) WHERE p.id = $id RETURN p.title", // Cypher statement
        new { id = 0 } // Parameters in the statement, if any
    );

    // Loop through the records asynchronously
    while (await reader.FetchAsync())
    {
        // Each current read in buffer can be reached via Current
        records.Add(reader.Current[0].ToString());
    }

    // Commit the transaction
    await tx.CommitAsync();
}
finally
{
    // asynchronously close session
    await session.CloseAsync();
}</code></pre><p>
                        
                     </p>
                     <div class="admonitionblock important">
                        <table>
                           <tbody>
                              <tr>
                                 <td class="icon"><i class="fa icon-important" title="important"></i></td>
                                 <td class="content">
                                    <p>It is always important to close the session object and it is suggested to keep <span class="strong"><strong>session.CloseAsync</strong></span> in a <span class="emphasis"><em>finally</em></span> block to make sure all resources (such as network connection) obtained by the session will always be cleaned up properly.
                                       The session <span class="strong"><strong>close</strong></span> method also enforces rolling back of the last uncommitted or failed transaction in this session.
                                       Thus it is optional to put <span class="strong"><strong>tx.CommitAsync</strong></span> or <span class="strong"><strong>tx.RollbackAsync</strong></span> in a <span class="emphasis"><em>finally</em></span> block as long as the <span class="strong"><strong>close</strong></span> of session where the transaction is created will be executed in an outer <span class="emphasis"><em>finally</em></span> block.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div>
                  <div class="informalexample include-with-java">
                     <p><span class="formalpara-title">Auto-commit transactions.&nbsp;</span>
                        
                     </p><pre class="programlisting highlight"><code data-lang="java">String query = "MATCH (p:Product) WHERE p.id = $id RETURN p.title";
Map&lt;String,Object&gt; parameters = Collections.singletonMap( "id", 0 );

Session session = driver.session();

return session.runAsync( query, parameters )
        .thenCompose( cursor -&gt; cursor.listAsync( record -&gt; record.get( 0 ).asString() ) )
        .exceptionally( error -&gt;
        {
            // query execution failed, print error and fallback to empty list of titles
            error.printStackTrace();
            return Collections.emptyList();
        } )
        .thenCompose( titles -&gt; session.closeAsync().thenApply( ignore -&gt; titles ) );</code></pre><p>
                        
                     </p>
                     <p><span class="formalpara-title">Transaction functions.&nbsp;</span>
                        
                     </p><pre class="programlisting highlight"><code data-lang="java">String query = "MATCH (p:Product) WHERE p.id = $id RETURN p.title";
Map&lt;String,Object&gt; parameters = Collections.singletonMap( "id", 0 );

Session session = driver.session();

return session.readTransactionAsync( tx -&gt;
        tx.runAsync( query, parameters )
                .thenCompose( cursor -&gt; cursor.forEachAsync( record -&gt;
                        // asynchronously print every record
                        System.out.println( record.get( 0 ).asString() ) ) )
);</code></pre><p>
                        
                     </p>
                     <p><span class="formalpara-title">Explicit transactions.&nbsp;</span>
                        
                     </p><pre class="programlisting highlight"><code data-lang="java">String query = "MATCH (p:Product) WHERE p.id = $id RETURN p.title";
Map&lt;String,Object&gt; parameters = Collections.singletonMap( "id", 0 );

Session session = driver.session();

Function&lt;Transaction,CompletionStage&lt;Void&gt;&gt; printSingleTitle = tx -&gt;
        tx.runAsync( query, parameters )
                .thenCompose( StatementResultCursor::singleAsync )
                .thenApply( record -&gt; record.get( 0 ).asString() )
                .thenApply( title -&gt;
                {
                    // single title fetched successfully
                    System.out.println( title );
                    return true; // signal to commit the transaction
                } )
                .exceptionally( error -&gt;
                {
                    // query execution failed
                    error.printStackTrace();
                    return false; // signal to rollback the transaction
                } )
                .thenCompose( commit -&gt; commit ? tx.commitAsync() : tx.rollbackAsync() );

return session.beginTransactionAsync()
        .thenCompose( printSingleTitle )
        .exceptionally( error -&gt;
        {
            // either commit or rollback failed
            error.printStackTrace();
            return null;
        } )
        .thenCompose( ignore -&gt; session.closeAsync() );</code></pre><p>
                        
                     </p>
                     <div class="admonitionblock important">
                        <table>
                           <tbody>
                              <tr>
                                 <td class="icon"><i class="fa icon-important" title="important"></i></td>
                                 <td class="content">
                                    <p>It is important to close the session object to make sure all resources (such as network connections) obtained by the session
                                       are cleaned up properly.
                                       It is therefore suggested to always do <code class="literal">Session#closeAsync()</code> at the end of the whole <code class="literal">CompletionStage</code> chain.
                                       Sessions should be closed regardless of whether the completes normally or exceptionally.
                                       Closing the session also enforces the rollback of the last uncommitted or failed transaction in the session.
                                       Thus it is optional to roll back the transaction using <code class="literal">Transaction#rollbackAsync()</code>, as long as the session is closed at the end of the full chain.
                                    </p>
                                 </td>
                              </tr>
                           </tbody>
                        </table>
                     </div>
                  </div>
               </div>
            </div>
         </section>
      </section>
      <footer><script type="text/javascript">
          (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
            (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
          m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
          })(window,document,'script','//www.google-analytics.com/analytics.js','ga');
          //Allow Linker
          ga('create', 'UA-1192232-34','auto', {'allowLinker': true});
          ga('send', 'pageview');
          // Load the plugin.
          ga('require', 'linker');
          // Define which domains to autoLink.
          ga('linker:autoLink', ['neo4j.org','neo4j.com','neotechnology.com','graphdatabases.com','graphconnect.com']);
        </script><script type="text/javascript">
          document.write(unescape("%3Cscript src='//munchkin.marketo.net/munchkin.js' type='text/javascript'%3E%3C/script%3E"));
        </script><script>Munchkin.init('773-GON-065');</script></footer>
   </body>
</html>